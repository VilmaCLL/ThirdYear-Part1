/**
 * 
 * @author Catalina Hernández Morales - 2015295
 * @author Vilma López Lemoine - 2015210
 * 
 * In order to be able to access the Queue from both directions, we decided to design a double linked list.
 * This class builds the Double Linked List. 
 */


public class MigrationLinkedList {

	Individual head;  //First candidate on queue.
	Individual tail;	//Last candidate on queue.
	public static int counter =0; //Counter to go through the Queue.
	int size; //Size of the Queue -number of Applicants currently on queue.

	//Default constructor. Initializes the objects and variables.
	public MigrationLinkedList(){ 

	      head = null;
	      tail = null;
	      size = 0;

	   } // end default constructor

	
		//Determines whether the queue is empty.
		public boolean isEmpty(){
			return size == 0;
		}
		
		
		//Adds an applicant to the list depending on the priority assigned. Depending on the case, the method adds a new person 
		//on a different position on the queue. Priority is classified from 1 to 3, being 1 for firsts on list and 3 for lasts.
		public void addArrival(Individual I1){

			if(isEmpty()){  //Adding first element to empty list

				head = I1;
				tail = head;
				size++;

			}else{
					if (size == 1 && I1.getPriority() == 1){ //Adding element to the list when there is only one element more 
															//and priority is 1
					
									if(head.getPriority() == 1){
										head.nextInLine = I1;
										I1.prevInLine = head;
										tail = I1;
										size ++;	
										
									}else if(head.getPriority() != 1){
										tail.prevInLine = I1;
										I1.nextInLine = tail;
										head = I1;
										size++;
									}

					}else if (I1.getPriority() == 1){ //Inserting when queue >1 and new applicant has priority 1

								Individual temp = head;
								Individual temp2 = null;

									for (int i= 1; i< size; i ++){
										if (temp.getPriority() == 2 || temp.getPriority() == 3){
											break;
										}else temp = temp.nextInLine;
									}

									 if ((temp.getPriority() == 2 || temp.getPriority() == 3) && temp == head){       //insertion on left side when priority 3 found.

											head.prevInLine = I1;
											I1.nextInLine = head;
											head = I1;


									}else if ((temp.getPriority() == 2 || temp.getPriority() == 3) && temp.prevInLine != null){

											temp2 = temp.prevInLine;
											temp2.nextInLine = I1;
											I1.prevInLine = temp2;
											temp.prevInLine = I1;
											I1.nextInLine = temp;
									}else{

										temp = tail;
										tail.nextInLine = I1;
										I1.prevInLine = tail;
										tail = I1;
									}


									size ++;

					}else if (I1.getPriority() == 2){ //Inserting when queue > 1 and applicant priority is 2
	
									Individual temp = head;
									Individual temp2 = null;
	
									for (int i= 1; i< size; i ++){
										if (temp.getPriority() == 3){
									break;
										}else temp = temp.nextInLine;
									}

									if (temp.getPriority() == 3 && temp == head){     

										head.prevInLine = I1;
										I1.nextInLine = head;
										head = I1;


									}else if (temp.getPriority() == 3 && temp.prevInLine != null){
										temp2 = temp.prevInLine;
										temp2.nextInLine = I1;
										I1.prevInLine = temp2;
										temp.prevInLine = I1;
										I1.nextInLine = temp;

									}else{

											temp = tail;
											tail.nextInLine = I1;
											I1.prevInLine = tail;
											tail = I1;
										}


									size ++;

					}else{ //Inserting when queue > 1 and priority is 3

							tail.nextInLine = I1;
							I1.prevInLine = tail;
							tail = I1;
							size ++;

						}

				}
		}


		//Searches the queue to find an applicant using their unique ID number, automatically generated by the system.
		//Shows full details of applicant, including position on queue.
		//Throws IllegalStateException and requires an integer from user input in its signature.
		public void findIndividualById (int IdNumber){ 
			
			Individual temp = head; //initializes the object and positions it at the beginning of the Queue (head).

			if(isEmpty()){
				throw new IllegalStateException("The List is empty");

			}else
				for (int i= 1; i<= size; i ++){

					if (temp.nextInLine == null && temp.getId() != IdNumber){

						throw new IllegalStateException("This ID is not registered");

					}else if (temp.getId() == IdNumber){

						System.out.println("Personal Id:" + " " + temp.getId());
						System.out.println("Name:"  + " "+ temp.getFirst_name());
						System.out.println("Last Name:"  + " " + temp.getLast_name());
						System.out.println("Passport Number:"  + " " + temp.getPassport());
						System.out.println("Priority:"  + " " + temp.getPriority());
						System.out.println("Position on queue:"  + " " + i);

					 break;

					}else temp = temp.nextInLine;
				}


		}
		
		
		//Adds a new applicant at any position on the queue. When an applicant is added using this method,
		//priority is not requested, however, the system assigns to the new applicant the priority of the applicant 
		//immediately ahead (or 1, in case the person is located on the first place of the list); so the 
		//method to add by priorities is not affected.
		//Throws IllegalStateException and requires an object to be passed and an integer from user input 
		//in its signature.
		public void addInSpecifiedPosition (Individual I2, int positionOnQueue){

					Individual temp = head;
					Individual temp2 = null;

			if(isEmpty()){

					throw new IllegalStateException("The Queue Is Empty");

				}else if (positionOnQueue > size +2){
						throw new IllegalStateException("The Queue Is Smaller Than the Position You Are Trying to Reach");
				}else
					if(positionOnQueue == 1)  {

							head.prevInLine = I2;
							I2.nextInLine = head;
							head = I2;
							I2.setPriority(1);

					}else if (positionOnQueue == size + 1){
						tail.nextInLine = I2;
						I2.prevInLine = tail;
						tail = I2;
						I2.setPriority(3);

					}else {

							for (int i= 2; i<= positionOnQueue; i ++){

								temp = temp.nextInLine;
							}

								temp2 = temp.prevInLine;
								temp2.nextInLine = I2;
								temp.prevInLine = I2;
								I2.prevInLine = temp2;
								I2.nextInLine = temp;

								int defaultPriority = temp2.getPriority();
								I2.setPriority(defaultPriority);

					}

					size ++;
			}
		
		
		// Eliminates one individual from any point of the list by connecting 
		//the next and the previous nodes between them (or just cutting the connection to tail or head).
		//The right individual to delete is found by using the unique id assigned by the system.
		//Throws IllegalStateException and requires an integer from user input in its signature (id of 
		//the individual to be deleted.
			
		public void deletePositionOnList (int idPosition){ 

				Individual temp = head;
				Individual temp2 = null;
				Individual temp3 = null;

			if(isEmpty()){

					throw new IllegalStateException("The Queue Is Empty");

			}else

				for (int i= 1; i< size; i ++){

					if (temp.getId() == idPosition){
							break;
						}else temp = temp.nextInLine;
					}


				if(temp.getId() == idPosition && temp == tail)  {

								deleteLastPosition ();

				}else if (temp.getId() == idPosition && temp == head){

									head = head.nextInLine;
									head.prevInLine = null;
									size --;

				}else {
								temp2 = temp.prevInLine;
								temp3 = temp.nextInLine;
								temp2.nextInLine = temp3;
								temp3.prevInLine = temp2;
								size --;
				}
		}

		
		// Eliminates N number of positions at the end of the queue.
		//It does it by calling a method that deletes just the last position N number of times.
		//Throws IllegalStateException and requires an integer from user input in its signature (number 
		//of positions to be deleted.
		public void deleteNLastPositions(int data){


			if(head == null) { // If the list is empty, there is no one to remove

				throw new IllegalStateException("The Queue Is Empty");

			}else if ( data <= 0) { // Position 0 or lower are not allowed
				
				throw new IllegalStateException("You Must Delete at Least 1 Place");
			
			}else if (data > size - 1) { // It is not possible to erase the whole list by using this method.

				throw new IllegalStateException("You Cannot Delete the Full List"); 

			}else{
				
				for (int i = 0; i < data; i++){
					
					deleteLastPosition ();
					}

			}

		}

		//Deletes only the last position of the Queue (tail)
		public void deleteLastPosition (){ 

			tail = tail.prevInLine;
			tail.nextInLine = null;
			size --;
		}

		//This method runs throughout the queue and returns the current queue with the details of all applicants
		//including their position on the queue.
		public String fullQueue() {
			
			if(head == null) {
				
				return "The list is empty";
			}
			
			else {
				int i = 1;
				Individual ICurrent = head;
				String allQueue = "";
				do {

					allQueue += "Position: " + i + "\n";
					allQueue += "ID: " + ICurrent.getId() + "\n";
					allQueue += "Arrival: " + ICurrent.getDate() + "\n";
					allQueue += "Name: " + ICurrent.getFirst_name() + "\n";
					allQueue += "Last Name: " + ICurrent.getLast_name() + "\n";
					allQueue += "Passport: " + ICurrent.getPassport() + "\n";
					allQueue += "Priority: " + ICurrent.getPriority() + "\n \n";

					ICurrent = ICurrent.nextInLine;
					
					i++;
					
				} while (i <= size);
				
				return allQueue;
			}

		}
}
